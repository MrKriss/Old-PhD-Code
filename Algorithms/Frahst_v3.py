# -*- coding: utf-8 -*-"""Created on Sat Mar 05 23:19:11 2011THIS IS THE VERSION TO RUN ON MAC, NOT WINDOWS@author: musselle"""from numpy import eye, zeros, dot, sqrt, log10, trace, arccos, nan, arangefrom numpy.random import randfrom numpy.linalg import qr, eig, norm, solvefrom matplotlib.pyplot import plot, figure, title, stepfrom artSigs import genCosSignals_no_rand , genCosSignalsimport scipy.io as siofrom utils import analysis, QRsolveA, pltSummaryfrom PedrosFrahst import frahst_pedrofrom Frahst_v3_1 import FRAHST_V3_1def FRAHST_V3(data, r=1, alpha=0.96, e_low=0.96, e_high=0.98, sci = -1, fix_init_Q = 0, holdOffTime=0, evalMetrics = 'F'):    """        Fast Rank Adaptive Householder Subspace Tracking Algorithm (FRAHST)          Version 3.0 - Combines good bits of Pedros version, with my correction of the bugs        """           # Initialise variables and data structures     #########################################    # Derived Variables     numStreams = data.shape[1]    timeSteps = data.shape[0]         #for energy test    lastChangeAt = 1        sumYSq = 0    sumXSq = 0        # Data Stores    res = {'hidden' :  zeros((timeSteps, numStreams)) * nan,  # Array for hidden Variables           'E_t' : zeros([timeSteps, 1]),                     # total energy of data            'E_dash_t' : zeros([timeSteps, 1]),                # hidden var energy           'e_ratio' : zeros([timeSteps, 1]),              # Energy ratio            'RSRE' : zeros([timeSteps, 1]),           # Relative squared Reconstruction error            'recon' : zeros([timeSteps, numStreams]),  # reconstructed data           'r_hist' : zeros([timeSteps, 1]), # history of r values            'anomalies' : []}                  # Initialisations     # Q_0    if fix_init_Q != 0:  # fix inital Q as identity         q_0 = eye(numStreams);        Q = q_0    else: # generate random orthonormal matrix N x r         Q = eye(numStreams) # Max size of Q        q_0, r_0 = qr(rand(numStreams,r))           Q[:,:r] = q_0                    # S_0    S = eye(numStreams) * 0.0001 # Avoids Singularity        # v-1    v = zeros((numStreams,1))             # NOTE algorithm's state (constant memory), S, Q and v are kept at max size        # Use iterable for data     iter_data = iter(data)                 # Main Loop #    #############    for t in range(1, timeSteps + 1):            #alias to matrices for current r        Qt  = Q[:, :r]        vt  = v[:r, :]        St  = S[:r, :r]            zt = iter_data.next()                  # Convert to a column Vector         zt = zt.reshape(zt.shape[0],1)             ht = dot(Qt.T , zt)                 Z = dot(zt.T,  zt) - dot(ht.T , ht)        if Z > 0 :                        # Refined version, sci accounts better for tracked eigenvalues            # This version calculates extra parameter only if needed#            if sci == -1 or sci == 1: #                u_vec = dot(St , vt)#                #                extra_term = 2 * alpha * sci * dot(u_vec, vt.T)#            else:#                extra_term = 0            #            #            X = (alpha * St) + dot(ht , ht.T) - extra_term#            if t in range(10): #                print extra_term                            u_vec = dot(St , vt)            X = (alpha * St) + (2 * alpha * dot(u_vec, vt.T)) + dot(ht , ht.T)                                                if t == 5:                print 'St = ', St                print 'vt = ', vt                print 'ht = ', ht                            # Solve Ax = b using QR updates - not strictly needed             A = X.T            B = sqrt(Z) * ht            b_vec = QRsolveA(A,B) # Note: changed to solve                   beta  = 4 * (dot(b_vec.T , b_vec) + 1)                    phi_sq = 0.5 + (1 / sqrt(beta))                    phi = sqrt(phi_sq)                gamma = (1 - 2 * phi_sq) / (2 * phi)                        delta = phi / sqrt(Z)                        vt = gamma * b_vec                         St = X - ((1 /delta) * dot(vt , ht.T))                        w = (delta * ht) - (vt)                         ee = delta * zt - dot(Qt , w)                         Qt = Qt - 2 * dot(ee , vt.T)                 ################            Q[:,:r] = Qt        v[:r,:] = vt        S[:r, :r] = St                ### FOR EVALUATION ###        #deviation from truth        if evalMetrics == 'T' :            if t == 1 :                res['subspace_error'] = zeros((timeSteps,1))                res['orthog_error'] = zeros((timeSteps,1))                                res['angle_error'] = zeros((timeSteps,1))                Cov_mat = zeros([numStreams,numStreams])                            # Calculate Covarentce Matrix of data up to time t               Cov_mat = alpha * Cov_mat +  dot(zt,  zt.T)            # Get eigenvalues and eigenvectors                         W , V = eig(Cov_mat)            # Use this to sort eigenVectors in according to deccending eigenvalue            eig_idx = W.argsort() # Get sort index            eig_idx = eig_idx[::-1] # Reverse order (default is accending)            # v_r = highest r eigen vectors (accoring to thier eigenvalue if sorted).            V_r = V[:, eig_idx[:r]]                      # Calculate subspace error                    C = dot(V_r , V_r.T) - dot(Qt , Qt.T)              res['subspace_error'][t-1,0] = 10 * log10(trace(dot(C.T , C))) #frobenius norm in dB                    # Calculate angle between projection matrixes            D = dot(dot(dot(V_r.T, Qt), Qt.T), V_r)             eigVal, eigVec = eig(D)            angle = arccos(sqrt(max(eigVal)))                    res['angle_error'][t-1,0] = angle                        # Calculate deviation from orthonormality            F = dot(Qt.T , Qt) - eye(r)            res['orthog_error'][t-1,0] = 10 * log10(trace(dot(F.T , F))) #frobenius norm in dB                      # Store Values         ###############                # Record reconstrunted z        z_hat = dot(Qt , ht)        res['recon'][t-1,:] = z_hat.T[0,:]                # Record hidden variables        res['hidden'][t-1, :r] = ht.T[0,:]                # Record RSRE        if t == 1:            top = 0.0            bot = 0.0                    top = top + (norm(zt - z_hat) ** 2 )        bot = bot + (norm(zt) ** 2)        res['RSRE'][t-1, 0] = top / bot                # Record r        res['r_hist'][t-1, 0] = r                # Rank Estimation         #################        # Calculate energies         sumXSq = alpha * sumXSq + sum(zt ** 2) # Energy of Data        sumYSq = alpha * sumYSq + sum(ht ** 2) # Energy of hidden Variables                        res['E_t'][t-1,0] = sumXSq         res['E_dash_t'][t-1,0] = sumYSq                                                      # 13 l                res['e_ratio'][t-1, 0] = sumYSq / sumXSq             # Adjust Q_t ans St for change in rr         if sumYSq < (e_low * sumXSq) and lastChangeAt < (t - holdOffTime) and r < numStreams :                        #Note indexing with r works like r + 1 as index is from 0 in python                                    # Extend Q by z_bar            h_dash = dot(Q[:, :r].T,  zt)            z_bar = zt - dot(Q[:, :r] , h_dash)            z_bar = z_bar / norm(z_bar)            Q[:numStreams, r] = z_bar.T[0,:]                        s_end  = sum(z_bar ** 2)                        # Set next row and column to zero            S[r, :] = 0.0            S[:, r] = 0.0            S[r, r] = s_end # change last element                        # new r, increment            r = r + 1    #        print "Increasing r to ", r," at time ", t, " (ratio energy", 100*sumYSq/sumXSq, ")\n"                        # Record time step of anomaly                        res['anomalies'].append(t)               # Reset lastChange                         lastChangeAt = t                    elif sumYSq > e_high*sumXSq and lastChangeAt < t - holdOffTime and r > 1 :            # Reset lastChange            lastChangeAt = t            # new r, decrement            r = r - 1     #       print "Decreasing r to ", r," at time ", t, " (ratio energy", 100*sumYSq/sumXSq, ")\n"                                    # No need to change S and Q as r index is decreased                             return res                        if __name__ == '__main__' :         # data = genCosSignals(0, -3.0)    # data = genCosSignals_no_rand(timesteps = 10000, N = 32)          # data = array([[0,0,0], [1,2,2], [1,3,4], [3,6,6], [5,6,10], [6,8,11]])           AbileneMat = sio.loadmat('/Users/Main/DataSets/Abilene/Abilene.mat')    data = AbileneMat['P']        n = data.shape[0]            e_high = 0.98    e_low = 0.96    alpha = 0.96    sci = 1        holdOFF = 0    # My version     res_me = FRAHST_V3(data, alpha=0.96, e_low=0.96, e_high=0.98, sci = -1, \    holdOffTime=holdOFF, fix_init_Q = 1, r = 1, evalMetrics = 'F')     res_me['Alg'] = 'My First Implimentation of FRAUST'    # metric_me, sets_me, anom_det_tab_me = analysis(res_me, AbileneMat['P_g_truth_tab'], n)        pltSummary(res_me, data)            # My second version     res_me2 = FRAHST_V3_1(data, alpha=0.96, e_low=0.96, e_high=0.98, \    holdOffTime=holdOFF, fix_init_Q = 1, r = 1, evalMetrics = 'F')     res_me2['Alg'] = 'My Second Implimentation of FRAUST'            pltSummary(res_me2, data)        #    # Pedros Version#    res_ped = frahst_pedro(data, r=1, alpha=0.96, energy_low=0.96, energy_high=0.98,  \#    holdOffTime=holdOFF, evaluateTruth='FALSE')##    res_ped['Alg'] = 'Pedros Implimentation of FRAUST'#    #    metric_ped, sets_ped, anom_det_tab_ped = analysis(res_ped, AbileneMat['P_g_truth_tab'], n)##    pltSummary(res_ped, data)#    